/*
	******************************************************************************************************************
	This project was done by 'Md Mahbubur Rahman' & 'Shamikul Amin' as a requirement of 'CS5803' course in FALL 2015.
	Department of Computer Science, Missouri S & T, Rolla, MO-65401, USA.
	******************************************************************************************************************
*/



#include <iostream>
#include <cstdlib>
#include <string.h>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <math.h>

using namespace std;
#define debug true		// only shows the results after applying SRT method
#define simulation false	// enable to see all the simulaiton steps inside SRT method
#define dout debug && cout
#define sout simulation && cout

int total_cost = 0; // counts the total execution time in delta_t

/////////////////////// Compound result structure ///////////////////
//self explanatory
class result{
	public:
	string remainder, quotient;
	int execution_time;
};
/////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// print helper functions////////////////////////////////////////////////////////////////////////////////////////////////
void println(){dout << endl;}
//specilized print function: decreses visual representation complexity for showing args in console
void println (string str){if(str[0] == '1'){str.insert(1, ".");}else if (str[0] == '0') {str[0] = '.';}else{}dout << str << endl;}
//specilized print function: decreses visual representation complexity for showing args in console
void print(string str){if(str[0] == '1'){str.insert(1, ".");}else if (str[0] == '0'){str[0] = '.';}else{}dout << " " << str << " ";}
//prints in special format to show simulaiton steps
void print_simulation_step(string description, string str, int b = 0, bool ir = false, bool st = false){
	int w = 5; int x = 15;
	if((str[0] == '1') && !st){str.insert(1, "."); w--;}else if (str[0] == '0') {str[0] = '.';}else{}
	if (!b) str.insert(str.length()/2 + 1, "  ");
	if(b == 1) {str = "\33[4m" + str + "\33[0m";}
	sout << std::setw(25) << std::left << description;
	sout << std::setw(w) << std::left << ":";
	sout << str << std::setw(x) << std::right;
	if ((!b && !ir) || (b == 2 && ir)) sout << total_cost << " Δt";
	sout << endl;
}
//print any label in middle of the window
void print_simulation_step(string step, int w){sout << std::setw(w) << std::right << "\33[4m" <<step << "\33[0m" << endl;}
//just a new line in simulaiton step
void print_simulation_step(){sout << endl;}
//print the result in proper format
void println(string aq, string b, result res){
	dout<<"A = "<<aq<<"\tB = "<<b<<"\nRemainder = "<<res.remainder<<"\tQuotient = "<<res.quotient<<"\tT = "<<res.execution_time<<" Δt.";
	dout << endl;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////// check divide overflow function ////////////////////////
// arg1 is value of A, arg2 is the value of B
// returns 1 if devide by zero overflow occurs
// returns 2 if a >= b overflow occurs,
// 0 is no overflow 
int arg_check_overflow(const string & arg1, const string & arg2){
	int overflow = 1; //assuming devide by zero overflow will occur

	// check if B is zero
	for (int i = 1; i < arg2.length(); i++){
		if(arg2[i] == '1'){
			overflow = 0; // B has at least one '1' bit
			break;
		}
	}
	if (overflow){ return overflow;	}							// return divide by zero overflow if occurs;

	//check if A >= B
	//Assuming this overflow will occur
	overflow = 2;	
	for(int j = 1; j < arg2.length(); j++){						// if no condition is satisfied inside forloop, A = B
		if((arg1[j] != arg2[j]) && (arg2[j] == '1')){			// confirms that B > A
			overflow = 0;
			break;
		}
		else if((arg1[j] != arg2[j]) && (arg2[j] == '0')){		// confirms that A > B
			break;
		}
	}
	return overflow;
}
///////////////////////////////////////////////////////////////////////////////



////////////////////// Normalize Args/////////////////////////
// arg: inplace normalization pointer for argmuent
// factor: number of bits normalized
// mode: defines whether normalizing or adjusting. default: normalization
void arg_normalize(string & arg, int & factor, int mode = 0){
	// normalize upto normalization factor
	if (mode == 1){
		int j = 1;
		while (j <= factor)
		{
			for(int i = 1; i < arg.length()-1; i++){
				arg[i] = arg[i+1];
			}
			arg[arg.length()-1] = '*';
			j++;
			total_cost += 3;							// each shift for adjustment costs 3dt
		}
	}
	// normalize and find the normalization factor
	else {
		while (arg[1] == '0'){
			for (int i = 1; i < arg.length()-1; i ++){
				arg[i] = arg[i+1];
			}
			arg[arg.length()-1] = '0';
			factor++;
			total_cost += 3; 							// each shift takes 3 dt time
		}
	}
}
//////////////////////////////////////////////////////////////

////////////////////// Compliment function ///////////////////
// arg1: unsigned value
// arg2: 2's compliment
void arg_compliment(const string & arg1, string & arg2){
	//string arg2 = arg1;
	total_cost += (arg1.length() -1);				// cost for 2's complitent , n * dt , n : numer of bits in arg1
	arg2 = arg1;
	arg2[0] = '1'; 	// represents negetive sign
	for (int i = 1; i < arg1.length(); i ++){
		if(arg1[i] == '0') arg2[i] = '1';
		else arg2 [i] = '0';
	}

	// if the least significant bit is 0, just change it to 1 and return
	if (arg2[arg1.length()-1] == '0'){
		arg2[arg1.length()-1] = '1';
		return;
	}

	// least significant bit is not 0
	// can't change the zero index, that represents the sign bit, j must be > 0.
	// normalizaiton also makes sure that adding 1 does not overflow
	for (int j = arg1.length()-1; j > 0; j --){											   
		if (arg2[j] == '0'){
			arg2[j] = '1';
			break;
		}
		arg2[j] = '0';
	}

	
}

//////////////////////////////////////////////////////////////

/////////////////////// Skip/Shift over zeroes/ones //////////////
//arg: aq
//count: shift_count , will be decresing
//ch: skip over 0 or 1
int arg_skip_over(string & arg, int & count, char ch){
	int flag = 0;
	int skiped = 0;
	while (arg[1] == ch){
		skiped = 1;
		for (int i = 1; i < arg.length() -1; i++){
			arg[i] = arg[i+1];
		}
		arg[arg.length()-1] = ch;
		count--;
		total_cost += 3;
		
		// check if shift_count is already n+1	
		if (count == 0) {
			flag = 1;
			break;
		} 
		// we are done as far as SRT methods step count's concern
		
	}

	if(skiped){
		string des = "Shift Over ";
		stringstream ss;
		ss << ch;
		string temp;
		ss >> temp;
		des = des + temp + "'s";
		print_simulation_step(des, arg);
	}
	return (flag == 1)? 0 : 1 ;
}
/////////////////////////////////////////////////////////////

//////////////////////// Add function (if-else-logic) ///////////////////////
//arg1: content of aq
//arg2: b or -b 
/* addition logic

	Cin  A  B   R  Cout
	0    0  0   0  0
	0    0  1   1  0
	0    1  0   1  0  
	0    1  1   0  1
	1    0  0   1  0
	1    0  1   0  1
	1    1  0   0  1
	1    1  1   1  1		
*/
void arg_add(string & arg1, const string & arg2){
	char carry = '0';
	for (int i = arg2.length(); i >= 0; i--){
		if (arg1[i] == '*') continue;	// we don't perform addition on bit marked as *

			 if(carry == '0' && arg1[i] == '0' && arg2[i] == '0'){ arg1[i] = '0'; carry = '0'; }
		else if(carry == '0' && arg1[i] == '0' && arg2[i] == '1'){ arg1[i] = '1'; carry = '0'; }
		else if(carry == '0' && arg1[i] == '1' && arg2[i] == '0'){ arg1[i] = '1'; carry = '0'; }
		else if(carry == '0' && arg1[i] == '1' && arg2[i] == '1'){ arg1[i] = '0'; carry = '1'; }
		else if(carry == '1' && arg1[i] == '0' && arg2[i] == '0'){ arg1[i] = '1'; carry = '0'; }
		else if(carry == '1' && arg1[i] == '0' && arg2[i] == '1'){ arg1[i] = '0'; carry = '1'; }
		else if(carry == '1' && arg1[i] == '1' && arg2[i] == '0'){ arg1[i] = '0'; carry = '1'; }
		else if(carry == '1' && arg1[i] == '1' && arg2[i] == '1'){ arg1[i] = '1'; carry = '1'; }
		else{ /* do nothing, could also check for * marker here but not neccessarily.*/ }
	}
	// discard the final C_out
	// cost calculation for one addition (carry select)
	int m = 2;								// 2 bit full adder
	int N = arg2.length() - 1;				// total number of bits to add
	if(N % m) { N += (N % m);}				// round divisor length while not integer multiple of m-bit adder
	int m_t = 6;							// total time for m bit full adder
	int temp = (((N / m) - 1) * 2) + m_t;	// generalized equation for cost calculation in addition
	total_cost += temp;
}
/////////////////////////////////////////////////////////////

//////////////////////// shift-left-replace-q0 //////////////
// arg: aq
//ch: assign 0 or 1 to Q_0
void arg_shl_new_q(string & arg, char ch){
	for (int i = 1; i < arg.length() -1; i++){
		arg[i] = arg[i+1];
	}
	arg[arg.length()-1] = ch;
	total_cost += 3;	// one left shift operation costs 3 dt
}
//////////////////////////////////////////////////////////////

////////////