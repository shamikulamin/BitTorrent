/*
	******************************************************************************************************************
	This project was done by 'Md Mahbubur Rahman' & 'Shamikul Amin' as a requirement of 'CS5803' course in FALL 2015.
	Department of Computer Science, Missouri S & T, Rolla, MO-65401, USA.
	******************************************************************************************************************
*/



#include <iostream>
#include <cstdlib>
#include <string.h>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <math.h>

using namespace std;
#define debug true		// only shows the results after applying SRT method
#define simulation false	// enable to see all the simulaiton steps inside SRT method
#define dout debug && cout
#define sout simulation && cout

int total_cost = 0; // counts the total execution time in delta_t

/////////////////////// Compound result structure ///////////////////
//self explanatory
class result{
	public:
	string remainder, quotient;
	int execution_t; int x = 15;
	if((str[0] == '1') && !st){str.insert(1, "."); w--;}else if (str[0] == '0') {str[0] = '.';}else{}
	if (!b) str.insert(str.length()/2 + 1, "  ");
	if(b == 1) {str = "\33[4m" + str + "\33[0m";}
	sout << std::setw(25) << std::left << description;
	sout << std::setw(w) << std::left << ":";
	sout << str << std::setw(x) << std::right;
	if ((!b && !ir) || (b == 2 && ir)) sout << total_cost << " Δt";
	sout << endl;
}
//print any label in middle of the window
void print_simulation_step(string step, int w){sout << std::setw(w) << std::right << "\33[4m" <<step << "\33[0m" << endl;}
//just a new line in simulaiton step
void print_simulation_step(){sout << endl;}
//print the result in proper format
void println(string aq, string b, result res){
	dout<<"A = "<<aq<<"\tB = "<<b<<"\nRemainder = "<<res.remainder<<"\tQuotient = "<<res.quotient<<"\tT = "<<res.execution_time<<" Δt.";
	dout << endl;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////// check divide overflow function ////////////////////////
// arg1 is value of A, arg2 is the value of B
// returns 1 if devide by zero overflow occurs
// returns 2 if a >= b overflow occurs,
// 0 is no overflow 
int arg_check_overflow(const string & arg1, const string & arg2){
	int overflow = 1; //assuming devide by zero overflow will occur

	// check if B is zero
	for (int i = 1; i < arg2.length(); i++){
		if(arg2[i] == '1'){
			overflow = 0; // B has at least one '1' bit
			break;
		}
	}
	if (overflow){ return overflow;	}							// return divide by zero overflow if occurs;

	//check if A >= B
	//Assuming this overflow will occur
	overflow = 2;	
	for(int j = 1; j < arg2.length(); j++){						// if no condition is satisfied inside forloop, A = B
		if((arg1[j] != arg2[j]) && (arg2[j] == '1')){			// confirms that B > A
			overflow = 0;
			break;
		}
		else if((arg1[j] != arg2[j]) && (arg2[j] == '0')){		// confirms that A > B
			break;
		}
	}
	return overflow;
}
///////////////////////////////////////////////////////////////////////////////



////////////////////// Normalize Args/////////////////////////
// arg: inplace normalization pointer for argmuent
// factor: number of bits normalized
// mode: defines whether normalizing or adjusting. default: normalization
void arg_normalize(string & arg, int & factor, int mode = 0){
	// normalize upto normalization factor
	if (mode == 1){
		int j = 1;
		while (j <= factor)
		{
			for(int i = 1; i < arg.length()-1; i++){
				arg[i] = arg[i+1];
			}
			arg[arg.length()-1] = '*';
			j++;
			total_cost += 3;							// each shift for adjustment costs 3dt
		}
	}
	// normalize and find the normalization factor
	else {
		while (arg[1] == '0'){
			for (int i = 1; i < arg.length()-1; i ++){
				arg[i] = arg[i+1];
			}
			arg[arg.length()-1] = '0';
			factor++;
			total_cost += 3; 							// each shift tak////////////////////////////////////////////////////

/////////////////////// Skip/Shift over zeroes/ones //////////////
//arg: aq
//count: shift_count , will be decresing
//ch: skip over 0 or 1
int arg_skip_over(string & arg, int & count, char ch){
	int flag = 0;
	int skiped = 0;
	while (arg[1] == ch){
		skiped = 1;
		for (int i = 1; i < arg.length() -1; i++){
			arg[i] = arg[i+1];
		}
		arg[arg.length()-1] = ch;
		count--;
		total_cost += 3;
		
		// check if shift_count is already n+1	
		if (count == 0) {
			flag = 1;
			break;
		} 
		// we are done as far as SRT methods step count's concern
		
	}

	if(skiped){
		string des = "Shift Over ";
		stringstream ss;
		ss << ch;
		string temp;
		ss >> temp;
		des = des + temp + "'s";
		print_simulation_step(des, arg);
	}
	return (flag == 1)? 0 : 1 ;
}
/////////////////////////////////////////////////////////////

//////////////////////// Add function (if-else-logic) ///////////////////////
//arg1: content of aq
//arg2: b or -b 
/* addition logic

	Cin  A  B   R  Co//////////// SRT Method //////////////////////////

result division_srt(string aq, string b){
	result div_result;  			// result will be placed here and send all together
	int adjustment_factor = 0; 		// calculate how many bits to normalize
	int shift_count = b.length(); 	// algorithm ends after exactly no-of-bits(b) + 1 left shifts				 			
	string comp_b;  				// holds the 2's compliment of normalized b
	bool pos_result = true;			// flag to keep track whether previsious result was negative or not
	aq[0] = b[0] = '0'; 			// removing the dot (.) and will be used as carry bit

	//////////// SRT algorithm starts ////////////////////////////////////////////////////////////////////////////////////
	print_simulation_step(); //blank line
	print_simulation_step();
	print_simulation_step("Initializations", 20);
	print_simulation_step("A Q", aq, 0, true);
	print_simulation_step("B", b, 2);
	arg_normalize(b , adjustment_factor); 		// normalize b
	print_simulation_step("Normalize B", b, 2, true);
	arg_compliment(b, comp_b);					// calculates 2's compliment of normalized b
	print_simulation_step("2's Com. (Normalize B)", comp_b, 2, true);
	print_simulation_step("SRT Steps", 25);

	arg_normalize(aq, adjustment_factor, 1);	//adjust AQ, and insert * in LSBs
	print_simulation_step("Adjust AQ", aq);
	arg_skip_over(aq, shift_count, '0');			//shift over 0's and insert 0's in LSBs. left shift_count starts from here !
	//simulation step is inside the function
												// check if shift_count is equal n + 1, n = number of bit in b
	while (shift_count > 0){
												// substract B
		if (pos_result){ 
			arg_add(aq, comp_b);
			print_simulation_step("Subtract B", comp_b, 1);
		}	
												// check if result is positive or negetive
		if (aq[0] == '0'){
			print_simulation_step("Positive result", aq);
			arg_shl_new_q(aq, '1');				// result positive, shift AQ left, q_0 = 1
			shift_count--;
			print_simulation_step("Shift AQ left, q_0 <- 1", aq);
												// check if we already did n + 1 left shifts
			if(shift_count == 0){
				